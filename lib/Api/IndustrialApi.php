<?php
/**
 * IndustrialApi
 * PHP version 5
 *
 * @category Class
 * @package  Samsara\Php\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Samsara API
 *
 * <style type=\"text/css\"> n {     padding: 1em;     width: 100%;     display: block;     margin: 28px 0; } n.info {     background-color: rgba(0, 51, 160, 0.1); } n.warning {     background-color: #fdf6e3; } i:before {     margin-right: 6px; } nh {     font-size: 1.5rem;     font-weight: 700;     line-height: 1.1;     display: block; } nb {     margin-top: 10px;     padding-left: 22px;     display: block; } </style>  # Overview  <n class=\"info\"> <nh> <i class=\"fa fa-info-circle\"></i> Something new! </nh> <nb> Welcome Samsara's new and improved API. Check out our FAQ [here](https://developers.samsara.com/docs/introducing-our-next-generation-api) to see what's changed and learn how to get started.<br> <br> Want to access the legacy API docs? You can find them [here](https://www.samsara.com/api).<br> <br> *Note: Because this is a new set of APIs, we have not transitioned all endpoints over to this standard. Endpoints that still use the legacy standards are indicated in the reference documentation. If you can't find an API that you're looking for, we encourage you to look for it in our [legacy API docs](https://www.samsara.com/api) as we continue to transition all endpoints over. Check back here for updates!*<br> <br> Submit your feedback [here](https://forms.gle/r4bs6HQshQAvBuwv6)! </nb> </n>  Samsara provides API endpoints so that you can build powerful applications and custom solutions with sensor data. Samsara has endpoints available to track and analyze sensors, vehicles, and entire fleets.  The Samsara API is a [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer). It uses standard [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) authentication, verbs, and response codes, and it returns [JSON](http://www.json.org/) response bodies. If you're familiar with what you can build with a REST API, then this will be your go-to API reference.  Visit [developers.samsara.com](https://developers.samsara.com) to find getting started guides and an API overview.  If you have any questions, reach out to us at [support@samsara.com](mailto:support@samsara.com).  ## Endpoints  All our APIs can be accessed through HTTP requests to URLs like:  ``` https://api.samsara.com/<endpoint> ```  For EU customers, this URL will be:  ``` https://api.eu.samsara.com/<endpoint> ```  <n class=\"warning\"> <nh> <i class=\"fa fa-exclamation-circle\"></i> Note </nh> <nb> Legacy endpoints will have the URL: `https://api.samsara.com/v1/<endpoint>` or `https://api.eu.samsara.com/v1/<endpoint>` </nb> </n>  ## Authentication  To authenticate your API request you will need to include your secret token. You can manage your API tokens in the [Dashboard](https://cloud.samsara.com). They are visible under `Settings->Organization->API Tokens`.  Your API tokens carry many privileges, so be sure to keep them secure. Do not share your secret API tokens in publicly accessible areas such as GitHub, client-side code, and so on.  Authentication to the API is performed via Bearer Token in the HTTP Authorization header. Provide your API token as the `access_token` value in an `Authorization: Bearer` header. You do not need to provide a password:  ```curl Authorization: Bearer {access_token} ```  All API requests must be made over [HTTPS](https://en.wikipedia.org/wiki/HTTPS). Calls made over plain HTTP or without authentication will fail.  ## Common Patterns  You can find more info about request methods, response codes, error codes, versioning, pagination, timestamps, and mini-objects [here](https://developers.samsara.com/docs/common-structures).
 *
 * OpenAPI spec version: 2019-09-13-oas3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.13
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Samsara\Php\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Samsara\Php\Client\ApiException;
use Samsara\Php\Client\Configuration;
use Samsara\Php\Client\HeaderSelector;
use Samsara\Php\Client\ObjectSerializer;

/**
 * IndustrialApi Class Doc Comment
 *
 * @category Class
 * @package  Samsara\Php\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class IndustrialApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getVisionRunsByCamera
     *
     * Fetch runs by camera
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\V1VisionRunsByCameraResponse
     */
    public function getVisionRunsByCamera($camera_id, $duration_ms, $end_ms = null)
    {
        list($response) = $this->getVisionRunsByCameraWithHttpInfo($camera_id, $duration_ms, $end_ms);
        return $response;
    }

    /**
     * Operation getVisionRunsByCameraWithHttpInfo
     *
     * Fetch runs by camera
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\V1VisionRunsByCameraResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVisionRunsByCameraWithHttpInfo($camera_id, $duration_ms, $end_ms = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionRunsByCameraResponse';
        $request = $this->getVisionRunsByCameraRequest($camera_id, $duration_ms, $end_ms);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1VisionRunsByCameraResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVisionRunsByCameraAsync
     *
     * Fetch runs by camera
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVisionRunsByCameraAsync($camera_id, $duration_ms, $end_ms = null)
    {
        return $this->getVisionRunsByCameraAsyncWithHttpInfo($camera_id, $duration_ms, $end_ms)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVisionRunsByCameraAsyncWithHttpInfo
     *
     * Fetch runs by camera
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVisionRunsByCameraAsyncWithHttpInfo($camera_id, $duration_ms, $end_ms = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionRunsByCameraResponse';
        $request = $this->getVisionRunsByCameraRequest($camera_id, $duration_ms, $end_ms);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVisionRunsByCamera'
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVisionRunsByCameraRequest($camera_id, $duration_ms, $end_ms = null)
    {
        // verify the required parameter 'camera_id' is set
        if ($camera_id === null || (is_array($camera_id) && count($camera_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $camera_id when calling getVisionRunsByCamera'
            );
        }
        // verify the required parameter 'duration_ms' is set
        if ($duration_ms === null || (is_array($duration_ms) && count($duration_ms) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $duration_ms when calling getVisionRunsByCamera'
            );
        }

        $resourcePath = '/v1/industrial/vision/runs/{camera_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($duration_ms !== null) {
            $queryParams['durationMs'] = ObjectSerializer::toQueryValue($duration_ms);
        }
        // query params
        if ($end_ms !== null) {
            $queryParams['endMs'] = ObjectSerializer::toQueryValue($end_ms);
        }

        // path params
        if ($camera_id !== null) {
            $resourcePath = str_replace(
                '{' . 'camera_id' . '}',
                ObjectSerializer::toPathValue($camera_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1getAllDataInputs
     *
     * Get industrial data
     *
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\InlineResponse20017
     */
    public function v1getAllDataInputs($start_ms = null, $end_ms = null)
    {
        list($response) = $this->v1getAllDataInputsWithHttpInfo($start_ms, $end_ms);
        return $response;
    }

    /**
     * Operation v1getAllDataInputsWithHttpInfo
     *
     * Get industrial data
     *
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\InlineResponse20017, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1getAllDataInputsWithHttpInfo($start_ms = null, $end_ms = null)
    {
        $returnType = '\Samsara\Php\Client\Model\InlineResponse20017';
        $request = $this->v1getAllDataInputsRequest($start_ms, $end_ms);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\InlineResponse20017',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1getAllDataInputsAsync
     *
     * Get industrial data
     *
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getAllDataInputsAsync($start_ms = null, $end_ms = null)
    {
        return $this->v1getAllDataInputsAsyncWithHttpInfo($start_ms, $end_ms)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1getAllDataInputsAsyncWithHttpInfo
     *
     * Get industrial data
     *
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getAllDataInputsAsyncWithHttpInfo($start_ms = null, $end_ms = null)
    {
        $returnType = '\Samsara\Php\Client\Model\InlineResponse20017';
        $request = $this->v1getAllDataInputsRequest($start_ms, $end_ms);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1getAllDataInputs'
     *
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function v1getAllDataInputsRequest($start_ms = null, $end_ms = null)
    {

        $resourcePath = '/v1/industrial/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_ms !== null) {
            $queryParams['startMs'] = ObjectSerializer::toQueryValue($start_ms);
        }
        // query params
        if ($end_ms !== null) {
            $queryParams['endMs'] = ObjectSerializer::toQueryValue($end_ms);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1getCameras
     *
     * Fetch industrial cameras
     *
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\V1VisionCamerasResponse
     */
    public function v1getCameras()
    {
        list($response) = $this->v1getCamerasWithHttpInfo();
        return $response;
    }

    /**
     * Operation v1getCamerasWithHttpInfo
     *
     * Fetch industrial cameras
     *
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\V1VisionCamerasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1getCamerasWithHttpInfo()
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionCamerasResponse';
        $request = $this->v1getCamerasRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1VisionCamerasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1getCamerasAsync
     *
     * Fetch industrial cameras
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getCamerasAsync()
    {
        return $this->v1getCamerasAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1getCamerasAsyncWithHttpInfo
     *
     * Fetch industrial cameras
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getCamerasAsyncWithHttpInfo()
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionCamerasResponse';
        $request = $this->v1getCamerasRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1getCameras'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function v1getCamerasRequest()
    {

        $resourcePath = '/v1/industrial/vision/cameras';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1getDataInput
     *
     * Get industrial data from a specific device
     *
     * @param  int $data_input_id ID of the data input. Must contain only digits 0-9. (required)
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\V1DataInputHistoryResponse
     */
    public function v1getDataInput($data_input_id, $start_ms = null, $end_ms = null)
    {
        list($response) = $this->v1getDataInputWithHttpInfo($data_input_id, $start_ms, $end_ms);
        return $response;
    }

    /**
     * Operation v1getDataInputWithHttpInfo
     *
     * Get industrial data from a specific device
     *
     * @param  int $data_input_id ID of the data input. Must contain only digits 0-9. (required)
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\V1DataInputHistoryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1getDataInputWithHttpInfo($data_input_id, $start_ms = null, $end_ms = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1DataInputHistoryResponse';
        $request = $this->v1getDataInputRequest($data_input_id, $start_ms, $end_ms);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1DataInputHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1getDataInputAsync
     *
     * Get industrial data from a specific device
     *
     * @param  int $data_input_id ID of the data input. Must contain only digits 0-9. (required)
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getDataInputAsync($data_input_id, $start_ms = null, $end_ms = null)
    {
        return $this->v1getDataInputAsyncWithHttpInfo($data_input_id, $start_ms, $end_ms)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1getDataInputAsyncWithHttpInfo
     *
     * Get industrial data from a specific device
     *
     * @param  int $data_input_id ID of the data input. Must contain only digits 0-9. (required)
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getDataInputAsyncWithHttpInfo($data_input_id, $start_ms = null, $end_ms = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1DataInputHistoryResponse';
        $request = $this->v1getDataInputRequest($data_input_id, $start_ms, $end_ms);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1getDataInput'
     *
     * @param  int $data_input_id ID of the data input. Must contain only digits 0-9. (required)
     * @param  int $start_ms Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs. (optional)
     * @param  int $end_ms Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function v1getDataInputRequest($data_input_id, $start_ms = null, $end_ms = null)
    {
        // verify the required parameter 'data_input_id' is set
        if ($data_input_id === null || (is_array($data_input_id) && count($data_input_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data_input_id when calling v1getDataInput'
            );
        }

        $resourcePath = '/v1/industrial/data/{data_input_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_ms !== null) {
            $queryParams['startMs'] = ObjectSerializer::toQueryValue($start_ms);
        }
        // query params
        if ($end_ms !== null) {
            $queryParams['endMs'] = ObjectSerializer::toQueryValue($end_ms);
        }

        // path params
        if ($data_input_id !== null) {
            $resourcePath = str_replace(
                '{' . 'data_input_id' . '}',
                ObjectSerializer::toPathValue($data_input_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1getMachines
     *
     * Get machines
     *
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\InlineResponse20018
     */
    public function v1getMachines()
    {
        list($response) = $this->v1getMachinesWithHttpInfo();
        return $response;
    }

    /**
     * Operation v1getMachinesWithHttpInfo
     *
     * Get machines
     *
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\InlineResponse20018, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1getMachinesWithHttpInfo()
    {
        $returnType = '\Samsara\Php\Client\Model\InlineResponse20018';
        $request = $this->v1getMachinesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\InlineResponse20018',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1getMachinesAsync
     *
     * Get machines
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getMachinesAsync()
    {
        return $this->v1getMachinesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1getMachinesAsyncWithHttpInfo
     *
     * Get machines
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getMachinesAsyncWithHttpInfo()
    {
        $returnType = '\Samsara\Php\Client\Model\InlineResponse20018';
        $request = $this->v1getMachinesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1getMachines'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function v1getMachinesRequest()
    {

        $resourcePath = '/v1/machines/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1getMachinesHistory
     *
     * Get machine history
     *
     * @param  \Samsara\Php\Client\Model\Body4 $body Time range to query for events (required)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\V1MachineHistoryResponse
     */
    public function v1getMachinesHistory($body)
    {
        list($response) = $this->v1getMachinesHistoryWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation v1getMachinesHistoryWithHttpInfo
     *
     * Get machine history
     *
     * @param  \Samsara\Php\Client\Model\Body4 $body Time range to query for events (required)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\V1MachineHistoryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1getMachinesHistoryWithHttpInfo($body)
    {
        $returnType = '\Samsara\Php\Client\Model\V1MachineHistoryResponse';
        $request = $this->v1getMachinesHistoryRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1MachineHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1getMachinesHistoryAsync
     *
     * Get machine history
     *
     * @param  \Samsara\Php\Client\Model\Body4 $body Time range to query for events (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getMachinesHistoryAsync($body)
    {
        return $this->v1getMachinesHistoryAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1getMachinesHistoryAsyncWithHttpInfo
     *
     * Get machine history
     *
     * @param  \Samsara\Php\Client\Model\Body4 $body Time range to query for events (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getMachinesHistoryAsyncWithHttpInfo($body)
    {
        $returnType = '\Samsara\Php\Client\Model\V1MachineHistoryResponse';
        $request = $this->v1getMachinesHistoryRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1getMachinesHistory'
     *
     * @param  \Samsara\Php\Client\Model\Body4 $body Time range to query for events (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function v1getMachinesHistoryRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling v1getMachinesHistory'
            );
        }

        $resourcePath = '/v1/machines/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1getVisionLatestRunCamera
     *
     * Fetch the latest run for a camera or program
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (optional)
     * @param  int $started_at_ms EndMs is an optional param. It will default to the current time. (optional)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     * @param  int $limit Limit is an integer value from 1 to 1,000. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\V1VisionRunByCameraResponse
     */
    public function v1getVisionLatestRunCamera($camera_id, $program_id = null, $started_at_ms = null, $include = null, $limit = null)
    {
        list($response) = $this->v1getVisionLatestRunCameraWithHttpInfo($camera_id, $program_id, $started_at_ms, $include, $limit);
        return $response;
    }

    /**
     * Operation v1getVisionLatestRunCameraWithHttpInfo
     *
     * Fetch the latest run for a camera or program
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (optional)
     * @param  int $started_at_ms EndMs is an optional param. It will default to the current time. (optional)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     * @param  int $limit Limit is an integer value from 1 to 1,000. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\V1VisionRunByCameraResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1getVisionLatestRunCameraWithHttpInfo($camera_id, $program_id = null, $started_at_ms = null, $include = null, $limit = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionRunByCameraResponse';
        $request = $this->v1getVisionLatestRunCameraRequest($camera_id, $program_id, $started_at_ms, $include, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1VisionRunByCameraResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1getVisionLatestRunCameraAsync
     *
     * Fetch the latest run for a camera or program
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (optional)
     * @param  int $started_at_ms EndMs is an optional param. It will default to the current time. (optional)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     * @param  int $limit Limit is an integer value from 1 to 1,000. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getVisionLatestRunCameraAsync($camera_id, $program_id = null, $started_at_ms = null, $include = null, $limit = null)
    {
        return $this->v1getVisionLatestRunCameraAsyncWithHttpInfo($camera_id, $program_id, $started_at_ms, $include, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1getVisionLatestRunCameraAsyncWithHttpInfo
     *
     * Fetch the latest run for a camera or program
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (optional)
     * @param  int $started_at_ms EndMs is an optional param. It will default to the current time. (optional)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     * @param  int $limit Limit is an integer value from 1 to 1,000. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getVisionLatestRunCameraAsyncWithHttpInfo($camera_id, $program_id = null, $started_at_ms = null, $include = null, $limit = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionRunByCameraResponse';
        $request = $this->v1getVisionLatestRunCameraRequest($camera_id, $program_id, $started_at_ms, $include, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1getVisionLatestRunCamera'
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (optional)
     * @param  int $started_at_ms EndMs is an optional param. It will default to the current time. (optional)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     * @param  int $limit Limit is an integer value from 1 to 1,000. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function v1getVisionLatestRunCameraRequest($camera_id, $program_id = null, $started_at_ms = null, $include = null, $limit = null)
    {
        // verify the required parameter 'camera_id' is set
        if ($camera_id === null || (is_array($camera_id) && count($camera_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $camera_id when calling v1getVisionLatestRunCamera'
            );
        }

        $resourcePath = '/v1/industrial/vision/run/camera/{camera_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($program_id !== null) {
            $queryParams['program_id'] = ObjectSerializer::toQueryValue($program_id);
        }
        // query params
        if ($started_at_ms !== null) {
            $queryParams['startedAtMs'] = ObjectSerializer::toQueryValue($started_at_ms);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }

        // path params
        if ($camera_id !== null) {
            $resourcePath = str_replace(
                '{' . 'camera_id' . '}',
                ObjectSerializer::toPathValue($camera_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1getVisionProgramsByCamera
     *
     * Fetch industrial camera programs
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\V1ProgramsForTheCameraResponse
     */
    public function v1getVisionProgramsByCamera($camera_id)
    {
        list($response) = $this->v1getVisionProgramsByCameraWithHttpInfo($camera_id);
        return $response;
    }

    /**
     * Operation v1getVisionProgramsByCameraWithHttpInfo
     *
     * Fetch industrial camera programs
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\V1ProgramsForTheCameraResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1getVisionProgramsByCameraWithHttpInfo($camera_id)
    {
        $returnType = '\Samsara\Php\Client\Model\V1ProgramsForTheCameraResponse';
        $request = $this->v1getVisionProgramsByCameraRequest($camera_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ProgramsForTheCameraResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1getVisionProgramsByCameraAsync
     *
     * Fetch industrial camera programs
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getVisionProgramsByCameraAsync($camera_id)
    {
        return $this->v1getVisionProgramsByCameraAsyncWithHttpInfo($camera_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1getVisionProgramsByCameraAsyncWithHttpInfo
     *
     * Fetch industrial camera programs
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getVisionProgramsByCameraAsyncWithHttpInfo($camera_id)
    {
        $returnType = '\Samsara\Php\Client\Model\V1ProgramsForTheCameraResponse';
        $request = $this->v1getVisionProgramsByCameraRequest($camera_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1getVisionProgramsByCamera'
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function v1getVisionProgramsByCameraRequest($camera_id)
    {
        // verify the required parameter 'camera_id' is set
        if ($camera_id === null || (is_array($camera_id) && count($camera_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $camera_id when calling v1getVisionProgramsByCamera'
            );
        }

        $resourcePath = '/v1/industrial/vision/cameras/{camera_id}/programs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($camera_id !== null) {
            $resourcePath = str_replace(
                '{' . 'camera_id' . '}',
                ObjectSerializer::toPathValue($camera_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1getVisionRuns
     *
     * Fetch runs
     *
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\V1VisionRunsResponse
     */
    public function v1getVisionRuns($duration_ms, $end_ms = null)
    {
        list($response) = $this->v1getVisionRunsWithHttpInfo($duration_ms, $end_ms);
        return $response;
    }

    /**
     * Operation v1getVisionRunsWithHttpInfo
     *
     * Fetch runs
     *
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\V1VisionRunsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1getVisionRunsWithHttpInfo($duration_ms, $end_ms = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionRunsResponse';
        $request = $this->v1getVisionRunsRequest($duration_ms, $end_ms);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1VisionRunsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1getVisionRunsAsync
     *
     * Fetch runs
     *
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getVisionRunsAsync($duration_ms, $end_ms = null)
    {
        return $this->v1getVisionRunsAsyncWithHttpInfo($duration_ms, $end_ms)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1getVisionRunsAsyncWithHttpInfo
     *
     * Fetch runs
     *
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getVisionRunsAsyncWithHttpInfo($duration_ms, $end_ms = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionRunsResponse';
        $request = $this->v1getVisionRunsRequest($duration_ms, $end_ms);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1getVisionRuns'
     *
     * @param  int $duration_ms DurationMs is a required param. This works with the EndMs parameter. Indicates the duration in which the visionRuns will be fetched (required)
     * @param  int $end_ms EndMs is an optional param. It will default to the current time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function v1getVisionRunsRequest($duration_ms, $end_ms = null)
    {
        // verify the required parameter 'duration_ms' is set
        if ($duration_ms === null || (is_array($duration_ms) && count($duration_ms) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $duration_ms when calling v1getVisionRuns'
            );
        }

        $resourcePath = '/v1/industrial/vision/runs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($duration_ms !== null) {
            $queryParams['durationMs'] = ObjectSerializer::toQueryValue($duration_ms);
        }
        // query params
        if ($end_ms !== null) {
            $queryParams['endMs'] = ObjectSerializer::toQueryValue($end_ms);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1getVisionRunsByCameraAndProgram
     *
     * Fetch runs by camera and program
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (required)
     * @param  int $started_at_ms Started_at_ms is a required param. Indicates the start time of the run to be fetched. (required)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Samsara\Php\Client\Model\V1VisionRunsByCameraAndProgramResponse
     */
    public function v1getVisionRunsByCameraAndProgram($camera_id, $program_id, $started_at_ms, $include = null)
    {
        list($response) = $this->v1getVisionRunsByCameraAndProgramWithHttpInfo($camera_id, $program_id, $started_at_ms, $include);
        return $response;
    }

    /**
     * Operation v1getVisionRunsByCameraAndProgramWithHttpInfo
     *
     * Fetch runs by camera and program
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (required)
     * @param  int $started_at_ms Started_at_ms is a required param. Indicates the start time of the run to be fetched. (required)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     *
     * @throws \Samsara\Php\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Samsara\Php\Client\Model\V1VisionRunsByCameraAndProgramResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1getVisionRunsByCameraAndProgramWithHttpInfo($camera_id, $program_id, $started_at_ms, $include = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionRunsByCameraAndProgramResponse';
        $request = $this->v1getVisionRunsByCameraAndProgramRequest($camera_id, $program_id, $started_at_ms, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1VisionRunsByCameraAndProgramResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Samsara\Php\Client\Model\V1ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1getVisionRunsByCameraAndProgramAsync
     *
     * Fetch runs by camera and program
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (required)
     * @param  int $started_at_ms Started_at_ms is a required param. Indicates the start time of the run to be fetched. (required)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getVisionRunsByCameraAndProgramAsync($camera_id, $program_id, $started_at_ms, $include = null)
    {
        return $this->v1getVisionRunsByCameraAndProgramAsyncWithHttpInfo($camera_id, $program_id, $started_at_ms, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1getVisionRunsByCameraAndProgramAsyncWithHttpInfo
     *
     * Fetch runs by camera and program
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (required)
     * @param  int $started_at_ms Started_at_ms is a required param. Indicates the start time of the run to be fetched. (required)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1getVisionRunsByCameraAndProgramAsyncWithHttpInfo($camera_id, $program_id, $started_at_ms, $include = null)
    {
        $returnType = '\Samsara\Php\Client\Model\V1VisionRunsByCameraAndProgramResponse';
        $request = $this->v1getVisionRunsByCameraAndProgramRequest($camera_id, $program_id, $started_at_ms, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1getVisionRunsByCameraAndProgram'
     *
     * @param  int $camera_id The camera_id should be valid for the given accessToken. (required)
     * @param  int $program_id The configured program&#x27;s ID on the camera. (required)
     * @param  int $started_at_ms Started_at_ms is a required param. Indicates the start time of the run to be fetched. (required)
     * @param  string $include Include is a filter parameter. Accepts &#x27;pass&#x27;, &#x27;reject&#x27; or &#x27;no_read&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function v1getVisionRunsByCameraAndProgramRequest($camera_id, $program_id, $started_at_ms, $include = null)
    {
        // verify the required parameter 'camera_id' is set
        if ($camera_id === null || (is_array($camera_id) && count($camera_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $camera_id when calling v1getVisionRunsByCameraAndProgram'
            );
        }
        // verify the required parameter 'program_id' is set
        if ($program_id === null || (is_array($program_id) && count($program_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $program_id when calling v1getVisionRunsByCameraAndProgram'
            );
        }
        // verify the required parameter 'started_at_ms' is set
        if ($started_at_ms === null || (is_array($started_at_ms) && count($started_at_ms) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $started_at_ms when calling v1getVisionRunsByCameraAndProgram'
            );
        }

        $resourcePath = '/v1/industrial/vision/runs/{camera_id}/{program_id}/{started_at_ms}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }

        // path params
        if ($camera_id !== null) {
            $resourcePath = str_replace(
                '{' . 'camera_id' . '}',
                ObjectSerializer::toPathValue($camera_id),
                $resourcePath
            );
        }
        // path params
        if ($program_id !== null) {
            $resourcePath = str_replace(
                '{' . 'program_id' . '}',
                ObjectSerializer::toPathValue($program_id),
                $resourcePath
            );
        }
        // path params
        if ($started_at_ms !== null) {
            $resourcePath = str_replace(
                '{' . 'started_at_ms' . '}',
                ObjectSerializer::toPathValue($started_at_ms),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getAccessToken()) {
            $defaultHeaders['Authorization'] = 'Bearer '. $this->config->getAccessToken();
        }
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
